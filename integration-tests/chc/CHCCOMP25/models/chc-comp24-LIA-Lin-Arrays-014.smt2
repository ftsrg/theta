(set-logic HORN)


(declare-fun |main@entry| ( Int ) Bool)
(declare-fun |main@orig.main.exit.split| ( ) Bool)
(declare-fun |main@.lr.ph| ( Int Int (Array Int Int) ) Bool)

(assert
  (forall ( (A Int) ) 
    (=>
      (and
        true
      )
      (main@entry A)
    )
  )
)
(assert
  (forall ( (A Int) (B (Array Int Int)) (C Int) (D Int) (E (Array Int Int)) (F Int) (G Int) (H Int) (I (Array Int Int)) (J Int) (K Int) (L Int) (M (Array Int Int)) (N Int) (O Int) (P Int) (Q (Array Int Int)) (R Int) (S Int) (T Int) (U (Array Int Int)) (V Int) (W Int) (X Int) (Y (Array Int Int)) (Z Int) (A1 Int) (B1 Int) (C1 (Array Int Int)) (D1 Int) (E1 Int) (F1 Int) (G1 (Array Int Int)) (H1 Int) (I1 Int) (J1 Int) (K1 Int) (L1 (Array Int Int)) (M1 Int) (N1 Int) (O1 (Array Int Int)) (P1 Int) (Q1 Int) (R1 Int) (S1 Bool) (T1 Bool) (U1 Bool) (V1 Bool) (W1 Int) (X1 Int) (Y1 Int) (Z1 (Array Int Int)) ) 
    (=>
      (and
        (main@entry K1)
        (let ((a!1 (= T1 (and (not (<= 10 R1)) (>= R1 0)))))
  (and (= E (store B C Q1))
       (= I (store E F G))
       (= M (store I J K))
       (= Q (store M N O))
       (= U (store Q R S))
       (= Y (store U V W))
       (= C1 (store Y Z A1))
       (= G1 (store C1 D1 E1))
       (= L1 (store G1 H1 I1))
       (= O1 (store L1 M1 N1))
       (= Z1 (store O1 P1 0))
       (= A K1)
       (= C Y1)
       (= D K1)
       (= F (+ 1 Y1))
       (= H K1)
       (= J (+ 2 Y1))
       (= L K1)
       (= N (+ 3 Y1))
       (= P K1)
       (= R (+ 4 Y1))
       (= T K1)
       (= V (+ 5 Y1))
       (= X K1)
       (= Z (+ 6 Y1))
       (= B1 K1)
       (= D1 (+ 7 Y1))
       (= F1 K1)
       (= H1 (+ 8 Y1))
       (= J1 K1)
       (= M1 (+ 9 Y1))
       (= P1 (+ 10 Y1))
       (= R1 (+ (- 48) Q1))
       (not (<= Y1 0))
       (or (not S1) (not V1) T1)
       (or (not V1) (not U1) (= W1 0))
       (or (not V1) (not U1) (= X1 W1))
       (or (not (<= C 0)) (<= Y1 0))
       (or (not (<= F 0)) (<= Y1 0))
       (or (not (<= J 0)) (<= Y1 0))
       (or (not (<= N 0)) (<= Y1 0))
       (or (not (<= R 0)) (<= Y1 0))
       (or (not (<= V 0)) (<= Y1 0))
       (or (not (<= Z 0)) (<= Y1 0))
       (or (not (<= D1 0)) (<= Y1 0))
       (or (not (<= H1 0)) (<= Y1 0))
       (or (not (<= M1 0)) (<= Y1 0))
       (or (not (<= P1 0)) (<= Y1 0))
       (or (not U1) (and V1 U1))
       (or (not V1) (and V1 S1))
       (= U1 true)
       a!1))
      )
      (main@.lr.ph X1 Y1 Z1)
    )
  )
)
(assert
  (forall ( (A Int) (B Int) (C Int) (D Int) (E Bool) (F Int) (G Bool) (H Bool) (I Int) (J Int) (K Int) (L (Array Int Int)) ) 
    (=>
      (and
        (main@.lr.ph A K L)
        (let ((a!1 (= E (and (not (<= 10 D)) (>= D 0)))))
  (and (= F (+ 1 A))
       (= B (+ K F))
       (= C (select L B))
       (= D (+ (- 48) C))
       (not (<= K 0))
       (or (not H) (not G) (= I F))
       (or (not H) (not G) (= J I))
       (or (not H) (not G) E)
       (or (not (<= B 0)) (<= K 0))
       (or (not G) (and H G))
       (= G true)
       a!1))
      )
      (main@.lr.ph J K L)
    )
  )
)
(assert
  (forall ( (A Int) (B (Array Int Int)) (C Int) (D Int) (E (Array Int Int)) (F Int) (G Int) (H Int) (I (Array Int Int)) (J Int) (K Int) (L Int) (M (Array Int Int)) (N Int) (O Int) (P Int) (Q (Array Int Int)) (R Int) (S Int) (T Int) (U (Array Int Int)) (V Int) (W Int) (X Int) (Y (Array Int Int)) (Z Int) (A1 Int) (B1 Int) (C1 (Array Int Int)) (D1 Int) (E1 Int) (F1 Int) (G1 (Array Int Int)) (H1 Int) (I1 Int) (J1 Int) (K1 Int) (L1 (Array Int Int)) (M1 Int) (N1 Int) (O1 Int) (P1 (Array Int Int)) (Q1 (Array Int Int)) (R1 Int) (S1 Int) (T1 Int) (U1 Bool) (V1 Bool) (W1 Bool) (X1 Bool) (Y1 Bool) ) 
    (=>
      (and
        (main@entry K1)
        (let ((a!1 (= V1 (and (not (<= 10 T1)) (>= T1 0)))))
  (and (= E (store B C S1))
       (= I (store E F G))
       (= M (store I J K))
       (= Q (store M N O))
       (= U (store Q R S))
       (= Y (store U V W))
       (= C1 (store Y Z A1))
       (= G1 (store C1 D1 E1))
       (= L1 (store G1 H1 I1))
       (= P1 (store Q1 R1 0))
       (= Q1 (store L1 M1 N1))
       (= A K1)
       (= D K1)
       (= H K1)
       (= L K1)
       (= P K1)
       (= T K1)
       (= X K1)
       (= B1 K1)
       (= F1 K1)
       (= R1 (+ 10 O1))
       (= T1 (+ (- 48) S1))
       (= C O1)
       (= F (+ 1 O1))
       (= J (+ 2 O1))
       (= N (+ 3 O1))
       (= R (+ 4 O1))
       (= V (+ 5 O1))
       (= Z (+ 6 O1))
       (= D1 (+ 7 O1))
       (= H1 (+ 8 O1))
       (= J1 K1)
       (= M1 (+ 9 O1))
       (not (<= O1 0))
       (or (not U1) (not V1) (not X1))
       (or (<= O1 0) (not (<= R1 0)))
       (or (<= O1 0) (not (<= C 0)))
       (or (<= O1 0) (not (<= F 0)))
       (or (<= O1 0) (not (<= J 0)))
       (or (<= O1 0) (not (<= N 0)))
       (or (<= O1 0) (not (<= R 0)))
       (or (<= O1 0) (not (<= V 0)))
       (or (<= O1 0) (not (<= Z 0)))
       (or (<= O1 0) (not (<= D1 0)))
       (or (<= O1 0) (not (<= H1 0)))
       (or (not (<= M1 0)) (<= O1 0))
       (or (not X1) (and U1 X1))
       (or (not X1) (not W1))
       (or (not Y1) (and Y1 X1))
       (not X1)
       (= Y1 true)
       a!1))
      )
      main@orig.main.exit.split
    )
  )
)
(assert
  (forall ( (A Int) (B Int) (C Int) (D (Array Int Int)) (E Int) (F Int) (G Int) (H Bool) (I Bool) (J Bool) (K Bool) (L Bool) (M Bool) ) 
    (=>
      (and
        (main@.lr.ph A C D)
        (let ((a!1 (= I (and (not (<= 10 G)) (>= G 0)))))
  (and (= B (+ 1 A))
       (= F (select D E))
       (= G (+ (- 48) F))
       (= E (+ C B))
       (not (<= C 0))
       (or (not H) (not I) (not J))
       (or (not (<= E 0)) (<= C 0))
       (or (not J) (and H J))
       (or (not L) (and L J))
       (or (not L) (not K))
       (or (not M) (and M L))
       (not L)
       (= M true)
       a!1))
      )
      main@orig.main.exit.split
    )
  )
)
(assert
  (forall ( (CHC_COMP_UNUSED Bool) ) 
    (=>
      (and
        main@orig.main.exit.split
        true
      )
      false
    )
  )
)

(check-sat)
(exit)
